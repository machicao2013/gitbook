java线程基础
======

** 杂项 **
1. Java中的每一个对象都有一个内部锁。如果一个方法用synchronized关键字声明，那么对象的锁将保护整个方法。也就是说，要调用该方法，线程必须获得内部的对象锁。
2. volatile变量不能提供原子性。

** 为什么stop和suspend方法被废弃掉 **
1. stop方法用来终止一个线程，suspend方法用来阻塞一个线程直至另一个线程调用resume。
2. stop和suspend方法有一个共同的特点：都试图控制一个给定线程的行为。
3. stop方法终止所有未结束的方法，包括run方法。当线程被终止，立即释放被它锁住的所有对象的锁。这会导致对象处于不一致的状态。例如从一个账户向另一个账户转账的过程中被终止，钱已经转出，但没有转入到目标账户，现在这个对象就被破环了。因为锁被释放，这种破坏会被其它尚未停止的线程观察到。
4. 一个线程要终止另一个线程时，无法知道什么时候调用stop方法是安全的，什么时候导致对像被破坏。因此，该方法被弃用了。在希望停止线程的时候应该中断线程，被中断的线程会在安全的时候停止。
5. suspend方法不会破坏对象。但是，如果用suspend挂起一个持有锁的线程，那么，该锁恢复之前是不可用的。如果调用suspend方法的线程试图获得同一个锁，那么程序死锁：被挂起的线程等待被恢复，而将其挂起的线程等待获得锁。

** java.util.concurrent包 **
1. java.util.concurrent包提供了映像、有序集和队列的高效实现：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet和ConcurrentLinkedQueue. 这些集合使用复杂的算法，通过允许并发地访问数据结构的不同部分来使竞争极小化。
2. 与大多数集合不同，size方法不必在常量时间内操作。确定这样的集合当前的大小通常需要遍历。
3. 集合返回弱一致性的迭代器。这意味这迭代器不一定能反映出它们被构造之后的所有的修改，但是，它们不会将同一个值返回两次，也不会抛出ConcurrentModificationException异常。
